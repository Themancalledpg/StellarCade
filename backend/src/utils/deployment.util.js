const fs = require('fs');
const path = require('path');

/**
 * Utility to parse and validate deploying artifacts generated by the rust-based deployment-scripts module.
 */

class DeploymentUtil {
    /**
     * Helper to resolve the location of a deterministic machine-readable deployment file.
     */
    static getDeploymentPath(networkProfile = 'Dev') {
        // Expects deployment artifacts typically stored at platform root or specific scripts directory.
        return path.join(__dirname, `../../../../deployments/${networkProfile.toLowerCase()}_deployments.json`);
    }

    /**
     * Safely loads contract addresses mapped by the deployment execution environment context.
     */
    static loadDeploymentMap(networkProfile = 'Dev') {
        const deployPath = this.getDeploymentPath(networkProfile);

        if (!fs.existsSync(deployPath)) {
            throw new Error(`Deployment artifact not found for profile: ${networkProfile} at ${deployPath}`);
        }

        try {
            const deploySource = fs.readFileSync(deployPath, 'utf8');
            const deployJson = JSON.parse(deploySource);

            const contractMap = {};

            // Iterate over explicitly deployed contracts to collect addresses gracefully
            if (deployJson.contracts) {
                for (const [contractAlias, state] of Object.entries(deployJson.contracts)) {
                    if (state && state.Deployed?.address) {
                        contractMap[contractAlias] = state.Deployed.address;
                    } else if (state && state.Initialized) {
                        // In the state representation, initialized overrides properties, but assuming
                        // initial deploy output saves state transitions appropriately.
                        // If rust script outputs `{ Initialized: { address: '...' }}` we map it:
                        if (state.Initialized.address) {
                            contractMap[contractAlias] = state.Initialized.address;
                        }
                    }
                }
            }

            return {
                network: deployJson.network,
                adminAddress: deployJson.admin_address,
                contracts: contractMap,
                timestamp: deployJson.timestamp
            };
        } catch (e) {
            throw new Error(`Malformed machine-readable deployment metadata: ${e.message}`);
        }
    }

    /**
     * Extracts a specific verified contract address cleanly for dependencies.
     */
    static getContractAddress(contractName, networkProfile = 'Dev') {
        const deployment = this.loadDeploymentMap(networkProfile);
        if (!deployment.contracts[contractName]) {
            throw new Error(`Validation Error: Address sequence for ${contractName} not found cleanly in registry.`);
        }
        return deployment.contracts[contractName];
    }
}

module.exports = DeploymentUtil;
